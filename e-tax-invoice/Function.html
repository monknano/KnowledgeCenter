<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Functions</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li>
<ul>
<li><a href="#การส่งค่ากลับจากฟังก์ชัน-the-return-statement">การส่งค่ากลับจากฟังก์ชัน (The return statement)</a></li>
<li><a href="#การส่งค่ากลับจากฟังก์ชันหลายค่า-returning-multiple-values">การส่งค่ากลับจากฟังก์ชันหลายค่า (Returning multiple values)</a></li>
<li><a href="#ขอบเขตของตัวแปร-scope-of-variables">ขอบเขตของตัวแปร (Scope of variables)</a></li>
<li><a href="#การเรียกตัวเอง-หรือการเวียนเกิด-recursion">การเรียกตัวเอง หรือการเวียนเกิด (Recursion)</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <ul>
<li>บรรทัดที่ 2 โปรแกรมทำการประกาศฟังก์ชัน lambda ทำหน้าที่ เชื่อมข้อมูลในพารามิเตอร์ a, b และ c เข้าไว้ด้วยกันภายในเครื่องหมาย […] โดยพารามิเตอร์แต่ละตัว  จะถูกกำหนดค่าเริ่มต้น (default value) ไว้คือ a = ‘A’, b = ‘B’ และ c = ‘C’ ตามลำดับ ผลลัพธ์ที่ได้จาก การคำนวณในฟังก์ชัน lambda จะเก็บไว้ในตัวแปรชื่อ mz</li>
<li>บรรทัดที่ 4 โปรแกรมทำการเรียกฟังก์ชัน lambda พร้อมกับส่งตัวอักษร ‘A’ เป็นอาร์กิวเมนต์เข้าไปด้วย ผลลัพธ์ที่ได้จาก lambda คือ [A B C] แม้ว่าโปรแกรมที่เรียก lambda จะส่งอาร์กิวเมนต์ไปไม่ครบตามจำนวนที่ฟังก์ชัน lambda ได้ประกาศไว้ (lambda ต้องการพารามิเตอร์ 3 ตัว) แต่ไพธอนจะ  ประเมินว่าพารามิเตอร์ที่เหลืออีก 2 ตัว จะใช้ค่า default ที่ฟังก์ชันกำหนดไว้มาท างานแทน</li>
</ul>
<h2 id="การส่งค่ากลับจากฟังก์ชัน-the-return-statement">การส่งค่ากลับจากฟังก์ชัน (The return statement)</h2>
<p>คำสั่ง <strong>return</strong> เป็นคำสั่งที่ใช้สำหรับส่งค่ากลับจากฟังก์ชันที่ถูกเรียก โดยค่าที่คืนกลับอาจจะเป็นค่าที่ถูกประมวลผลในรูปของนิพจน์ ตัวแปร ฟังก์ชัน หรือค่าคงที่ก็ได้ ซึ่งมีรูปแบบคือ</p>
<pre><code>return [expression]
</code></pre>
<p>ตัวอย่างการส่งค่ากลับที่เกิดจากนิพจน์ทางคณิตศาสตร์ เช่น. **return (<em><em>33</em>(s-f)/c</em>(d+33))</p>
<ul>
<li>การส่งค่ากลับจากตัวแปร เช่น <strong>return</strong> y = 2.5 * E0.38</li>
<li>การส่งค่ากลับจากค่าคงที่ เช่น <strong>return</strong> -1</li>
<li>การส่งค่ากลับจากฟังก์ชัน เช่น <strong>return</strong> myfunc(5, 3.5)</li>
<li>ไม่มีการส่งค่ากลับจากฟังก์ชัน เช่น <strong>return</strong> หรือ <strong>return;</strong></li>
</ul>
<p>คำสั่ง return หรือ return; ไพธอนมองว่าเป็นการส่งคืนค่า None ซึ่งไม่สามารถน าค่าดังกล่าวไป  ใช้ประโยชน์อะไรได้ในการเขียนโปรแกรม สำหรับโปรแกรมตัวอย่างการคืนค่ากลับจากฟังก์ชัน</p>
<pre><code># Return from function
# Function definition is here
def sum(arg1, arg2)enter code here:
    # Add both the parameters and return them."
    total = arg1 + arg2
    print ("Inside the function : ", total)
    return total

# Now you can call sum function
total = sum(10, 20);
print ("Outside the function : ", total)
</code></pre>
<p><strong>Output:</strong><br>
Inside the function :  30<br>
Outside the function :  30</p>
<ul>
<li>บรรทัดที่ 3 โปรแกรมประกาศฟังก์ชันชื่อ sum ทำหน้าที่บวกเลข 2  จำนวนเข้าด้วยกันและพิมพ์ค่าที่รวมได้ออกจอภาพ โดยมีพารามิเตอร์ 2 ตัวคือ agr1 และ agr2</li>
<li>บรรทัด ที่ 5 โปรแกรมรวมค่าในพารามิเตอร์ arg1 กับ arg2 เข้าไว้ด้วยกัน ผลลัพธ์ที่ได้เก็บไว้ในตัวแปรชื่อ total</li>
<li>บรรทัดที่ 6 โปรแกรมสั่งพิมพ์ค่าในตัวแปร total ออกจอภาพ บรรทัดที่ 7 ฟังก์ชันส่งค่าในตัวแปร total<br>
กลับไปให้แก่ผู้เรียกใช้งาน</li>
<li>บรรทัดที่ 9 โปรแกรมเรียกใช้ฟังก์ชัน sum พร้อมกับค่าคงที่เป็นอาร์กิวเมนต์ให้กับฟังก์ชัน คือ  10 และ 20 ผลลัพธ์ที่ได้จากฟังก์ชันคือ 30</li>
<li>บรรทัดที่ 10 โปรแกรมทดสอบพิมพ์ค่าในตัวแปร total ที่ส่งกลับมาจากฟังก์ชัน sum ผลลัพธ์ที่ได้คือ 30 เหมือนเดิม จากโปรแกรมข้างต้นมีข้อสังเกตว่าตัวแปร  total ที่ประกาศไว้ภายในฟังก์ชันและภายนอกฟังก์ชันไม่ใช่ตัวแปรตัวเดียวกัน</li>
</ul>
<h3 id="ตัวอย่างโปรแกรมเครื่องคิดเลขขนาดเล็ก-mini-calculator-program">ตัวอย่างโปรแกรมเครื่องคิดเลขขนาดเล็ก (mini-calculator program)</h3>
<pre><code># Mini-calculator program
def menu():

 # print what options you have
    print("Welcome to calculator program")
    print("your options are:")
    print(" ")
    print("1) Addition")
    print("2) Subtraction")
    print("3) Multiplication")
    print("4) Division")
    print("5) Quit calculator program")
    print(" ")
    return int(input("Choose your option: "))

# this adds two numbers given
def add(a, b):
    print("You chose the Addition")
    print("Result of ", a, "+", b, "=", a + b)
    return a + b

# this subtracts two numbers given
def sub(a, b):
    print("You chose the Subtraction")
    print ("Result of ",a, "-", b, "=", a - b)
    return a - b

# this multiplies two numbers given
def mul(a, b):
    print("You chose the Multiplication")
    print ("Result of ",a, "*", b, "=", a * b)
    return a * b
 
# this divides two numbers given
def div(a, b):
    print("You chose the Division")
    if b != 0:
        print ("Result of ",a, "/", b, "=", a / b)
        return a / b
    else:
        print("Can't divide by zero")
        return False

# this is main program for control all def
def main():
    loop = 1
    choice = 0
    while loop == 1:
        choice = menu()
        if choice == 1:
            add(int(input("Number 1:")),int(input("Number2:")))
        elif choice == 2:
            sub(int(input("Number 1:")),int(input("Number2:")))
        elif choice == 3:
            mul(int(input("Number 1:")),int(input("Number2:")))
        elif choice == 4:
            div(int(input("Number 1:")),int(input("Number2:")))
        elif choice == 5:
            loop = 0
    else:
        print("Good bye! ")

if __name__ == "__main__":
    main()
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>
Welcome to calculator program
your options are:
 
1) Addition
2) Subtraction
3) Multiplication
4) Division
5) Quit calculator program
 
Choose your option: 1
Number 1:1
Number2:2
You chose the Addition
Result of  1 + 2 = 3
Welcome to calculator program
your options are:
 
1) Addition
2) Subtraction
3) Multiplication
4) Division
5) Quit calculator program
 
Choose your option: 5
Good bye!
</code></pre>
<p>โปรแกรมเครื่องคิดเลขขนาดเล็กที่มีฟังก์ชันการทำงาน  ทั้งหมด 6 ฟังก์ชันคือ ฟังก์ชันหลัก (main), สร้างเมนู (menu), การบวก (add), การลบ (sub), การคูณ  (mul), การหาร (div) ดังนี้</p>
<ul>
<li>บรรทัดที่ 2 ประกาศฟังก์ชันชื่อว่า menu ท าหน้าที่แสดงคุณสมบัติต่างๆ (Features) ของเครื่องคิดเลขที่เตรียมไว้ให้ใช้งาน เช่น เลือก 1 คือการบวก, 2 คือการลบ ถ้าต้องการออกจากโปรแกรมให้เลือก 5 เป็นต้น ฟังก์ชันนี้ไม่ต้องการพารามิเตอร์เพื่อใช้ในการท างาน แต่ฟังก์ชันจะส่งค่ากลับไปให้แก่ ผู้เรียกใช้เป็นเลขจำนวนเต็มที่ผู้ใช้เลือกว่าต้องการให้เครื่องคิดเลขท าอะไร (บรรทัดที่ 13) เช่น ถ้าเลือก  1 คือการบวก เป็นต้น</li>
<li>บรรทัดที่ 16 โปรแกรมประกาศฟังก์ชัน add ท าหน้าที่บวกเลข 2 จ านวนเข้าด้วยกัน และส่งผลลัพธ์ที่ได้จากการบวกคืนให้แก่ผู้เรียก โดยฟังก์ชันมีพารามิเตอร์ 2 ตัวคือ a และ b</li>
<li>บรรทัดที่ 22 โปรแกรมประกาศฟังก์ชัน sub ท าหน้าที่ลบเลข 2 จ านวน และส่งผลลัพธ์ที่ได้จากการลบคืนให้แก่ผู้เรียก โดยฟังก์ชันมีพารามิเตอร์ 2 ตัวคือ a และ b</li>
<li>บรรทัดที่ 28 โปรแกรมประกาศฟังก์ชัน mul ท าหน้าที่คูณเลข 2 จ านวน และส่งผลลัพธ์ที่ได้จากการคูณคืนให้แก่ผู้เรียก โดยฟังก์ชันมีพารามิเตอร์ 2 ตัวคือ a และ b</li>
<li>บรรทัดที่ 34 โปรแกรมประกาศฟังก์ชัน div ท าหน้าที่หารเลข 2 จ านวน และส่งผลลัพธ์ที่ได้จากการหารคืนให้แก่ผู้เรียก โดยฟังก์ชันมีพารามิเตอร์ 2 ตัวคือ a และ b ภายในฟังก์ชันมีการตรวจสอบด้วยว่าค่าที่ใช้หารต้องไม่เป็น 0 ถ้าเป็น 0 ฟังก์ชันจะส่งค่ากลับเป็น False</li>
<li>บรรทัดที่ 44 โปรแกรมประกาศฟังก์ชันชื่อ main ท าหน้าที่ควบคุมการท างานของเครื่องคิดเลขในฟังก์ชันไม่มีพารามิเตอร์เพื่อใช้ทำงาน - บรรทัดที่ 45 โปรแกรมประกาศตัวแปรชื่อว่า loop มีค่าเริ่มต้น เท่ากับ 1 ใช้สำหรับตรวจสอบว่าผู้ใช้ต้องการออกจากโปรแกรมหรือไม่ ถ้า loop เท่ากับ 0 แสดงว่าผู้ใช้ ต้องการออกจากโปรแกรม</li>
<li>บรรทัดที่ 46 ประกาศตัวแปรชื่อ choice มีค่าเริ่มต้นเป็น 0 มีหน้าที่เก็บค่าตัวเลขจำนวนเต็มที่ส่งกลับมาจากฟังก์ชัน menu (เป็นตัวเลขที่บอกให้โปรแกรมทราบว่าผู้ใช้เลือกใช้  คุณสมบัติใดของเครื่องคิดเลข) บรรทัดที่ 47 โปรแกรมตรวจสอบเงื่อนใขด้วยคำสั่ง while ว่า loop มีค่าเท่ากับ 1 หรือไม่ ผลจากการตรวจสอบเป็นจริง (เพราะบรรทัดที่ 45 มีการกำหนดให้ loop = 1 )</li>
<li>บรรทัด  ที่ 48 โปรแกรมเรียกฟังก์ชัน menu เพื่อให้ผู้ใช้เลือกว่าต้องการให้เครื่องคิดเลขทำฟังก์ชันอะไร ที่ส่งกลับมาจากฟังก์ชัน menu คือตัวเลขจ านวนเต็มตั้งแต่ 1 – 5 เท่านั้น แต่ถ้าผู้ใช้ป้อนตัวเลขที่ไม่ใช่ 1  – 5 โปรแกรมจะกลับไปรับค่าใหม่
<ul>
<li>ถ้าผู้ใช้เลือก 1 (บรรทัดที่ 49) โปรแกรมจะแสดงข้อความว่า “Number 1:” และ “Number 2:”  เพื่อรอให้ผู้ใช้ป้อนตัวเลขใดๆ 2 จ านวนทางแป้นพิมพ์ เมื่อผู้ใช้ป้อนข้อมูลทั้ง 2 จ านวนแล้ว โปรแกรมจะไปทำงานในฟังก์ชัน add (การบวก) ผลลัพธ์ที่ได้จะถูกพิมพ์ออกจอภาพ และโปรแกรมจะกลับมารอรับ<br>
คำสั่งต่อไปในโปรแกรมหลัก (main)</li>
<li>ถ้าผู้ใช้เลือก 2 (บรรทัดที่ 51 ) โปรแกรมจะแสดงข้อความว่า “Number 1:” และ “Number 2:”<br>
เช่นเดิม เพื่อรอให้ผู้ใช้ป้อนตัวเลขใดๆ 2 จ านวนทางแป้นพิมพ์ เมื่อผู้ใช้ป้อนข้อมูลทั้ง 2 จ านวนแล้ว<br>
โปรแกรมจะไปท างานในฟังก์ชัน sub (การลบ) ผลลัพธ์ที่ได้จะถูกพิมพ์ออกจอภาพ และโปรแกรมจะ<br>
กลับมารอรับค าสั่งต่อไปในโปรแกรมหลัก (main)</li>
<li>ถ้าผู้ใช้เลือก 3 หรือ 4 (บรรทัดที่ 53 หรือ 55) โปรแกรมจะแสดงข้อความว่า “Number 1:” และ  “Number 2:” เช่นเดียวกัน เพื่อรอให้ผู้ใช้ป้อนตัวเลขใดๆ 2 จำนวนทางแป้นพิมพ์ เมื่อผู้ใช้ป้อนข้อมูลทั้ง 2 จำนวนแล้ว โปรแกรมจะไปท างานในฟังก์ชัน mul (การคูณ) หรือ div (การหาร) ผลลัพธ์ที่ได้จะถูกพิมพ์ออกจอภาพ และโปรแกรมจะกลับมารอรับคำสั่งต่อไปในโปรแกรมหลัก (main) เช่นเดิม</li>
<li>ถ้าผู้ใช้เลือก 5 (บรรทัดที่ 57) โปรแกรมจะพิมพ์ข้อความว่า “Good bye!” พร้อมกับยุติการทำงานของโปรแกรมทันที แต่ถ้าผู้ใช้ป้อนเป็นตัวเลขใด ๆ ที่ไม่ใช่ 1 – 5 โปรแกรมจะกลับไปรอให้ผู้ใช้ป้อนข้อมูลใหม่ สำหรับเอาต์พุตของการใช้งานโปรแกรมเครื่องคิดเลขแสดงในตัวอย่างข้างบน</li>
</ul>
</li>
</ul>
<p><strong>หมายเหตุ:</strong> โปรแกรมนี้ใช้ได้กับเลขจำนวนเต็มเท่านั้น ไม่สามารถใช้ได้กับเลขจ านวนจริง ถ้าผู้เขียนต้องการให้โปรแกรมสามารถใช้งานได้ทั้งจำนวนเต็มและจำนวนจริงให้แก้ไขโปรแกรมในบรรทัดที่ 50, 52, 54 และ 56 ดังนี้</p>
<pre><code>	จาก add(**int**(input("Number 1:")), **int**(input("Number 2:")))  
	เป็น add(**float**(input("Number 1:")) , **float**(input("Number 2:")))
</code></pre>
<h2 id="การส่งค่ากลับจากฟังก์ชันหลายค่า-returning-multiple-values">การส่งค่ากลับจากฟังก์ชันหลายค่า (Returning multiple values)</h2>
<p>ในภาษาระดับสูงส่วนใหญ่ ฟังก์ชันสามารถส่งค่ากลับได้เพียงค่าเดียวเท่านั้น แต่ในไพธอนยอมให้ผู้เขียนโปรแกรมสามารถส่งค่ากลับจากฟังก์ชันได้มากกว่า 1 ค่า โดยอาศัยตัวแปรชนิดทัพเพิลช่วยในการทำงาน ซึ่งมีรูปแบบการใช้งานตามตัวอย่างต่อไปนี้</p>
<h3 id="ตัวอย่าง-returning-multiple-values">ตัวอย่าง returning multiple values</h3>
<pre><code># Returning multiple values
import random
def rollDice():
    return (1 + random.randrange(6), 1 +
random.randrange(6))
d1, d2 = rollDice()
print (d1,",",d2)
d1, d2 = rollDice()
print (d1,",",d2)
d1, d2 = rollDice()
print (d1,",",d2)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>6 , 3
3 , 3
2 , 1
</code></pre>
<ul>
<li>บรรทัดที่ 3 ประกาศฟังก์ชันชื่อ rollDice มีหน้าที่สุ่มแต้มของลูกเต๋า 2 ลูก (บรรทัดที่ 4) ตัวเลขที่สุ่มได้จะอยู่ในช่วงระหว่าง 1 – 6 (เท่ากับจุดบนหน้าของลูกเต๋า) และ ส่งแต้มที่สุ่มได้ทั้ง 2 ค่ากลับคืนให้กับผู้เรียก</li>
<li>บรรทัดที่ 5 โปรแกรมท าการเรียกใช้ฟังก์ชัน rollDice ค่าที่ส่งกลับมาจากฟังก์ชัน rollDice มี 2 ค่า เพราะลูกเต๋ามี 2 ลูก (เป็นข้อมูลชนิดทัพเพิล) ค่าทั้งสองจะถูกเก็บไว้ในตัวแปรชนิด int ชื่อ d1 และ  d2 ตามลำดับ จากนั้นบรรทัดที่ 6 โปรแกรมทำการพิมพ์ค่าที่เก็บอยู่ในตัวแปร d1 และ d2 สำหรับ  โปรแกรมบรรทัดที่ 7 – 10 โปรแกรมทำการสุ่มโยนลูกเต๋าหลาย ๆ ครั้ง</li>
<li></li>
</ul>
<h2 id="ขอบเขตของตัวแปร-scope-of-variables">ขอบเขตของตัวแปร (Scope of variables)</h2>
<p>ขอบเขตของตัวแปรคือ บริเวณหรืออาณาเขตที่สามารถเข้าถึงตัวแปรหรืออ้างถึงเพื่อใช้งานได้  โดยตัวแปรที่อยู่ในโปรแกรมหลัก เรียกว่า ตัวแปรชนิดโกลบอล (Global) ส าหรับตัวแปรที่อยู่ในฟังก์ชัน  เรียกว่า ตัวแปรชนิดโลคอล (Local) ซึ่งมีรายละเอียดดังต่อไปนี้</p>
<h3 id="ตัวแปรโกลบอล">ตัวแปรโกลบอล</h3>
<p>ตัวแปรชนิดนี้จะประกาศไว้ในส่วนของโปรแกรมหลัก (main program)  และสามารถเข้าถึงตัวแปรดังกล่าว ได้ตลอดทั้งโปรแกรม (โปรแกรมส่วนอื่นๆ สามารถ  เรียกใช้ตัวแปรแบบโกลบอลจากที่ใดๆ ก็ได้ในโปรแกรม)</p>
<h3 id="ตัวแปรชนิดโลคอล">ตัวแปรชนิดโลคอล</h3>
<p>ตัวแปรชนิดนี้จะประกาศไว้ในฟังก์ชันเท่านั้น ขอบเขตการทำงานของ<br>
ตัวแปรจะอยู่เฉพาะภายในฟังก์ชันเท่านั้น เมื่อเสร็จสิ้นการท างานภายในฟังก์ชัน ตัวแปรเหล่านั้นจะถูกลบทิ้งทันที</p>
<pre><code># Scope of variables
total = 0; # This is global variable.
def sum(arg1, arg2):
    # Add both the parameters and return them.
    total = arg1 + arg2; # Here total is local variable.
    print ("Total of local variable inside function : ",total)
    return total;
 # calling sum function
sum(5, 10);
print ("Total of global variable outside function : ",total)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Total of local variable inside function :  15
Total of global variable outside function :  0
</code></pre>
<p><strong>ตัวอย่างแสดงการกำหนดตัวแปรโกลบอลและโลคอล (Define variables)</strong></p>
<pre><code>def modifyVar1():
    var1, var2 = 10, 20 #These are local variables
    print("Local variables are var1 = %d, var2 = %d"%(var1,var2))
def modifyVar2(var1, var2):
    var1 = 30 #var1 is local, and var2 is global
    print("Local variable var1 = %d, and global var2 = %d"%(var1, var2))
def modifyVar3(var1):
    global var2
    var2 = 3
    return var1**var2
def modifyVar4():
    global var1
    var1 = var1**2
    return

var1, var2 = 5, 5
modifyVar1()
modifyVar2(5, 10)
print("Var1 and Var2 in main program = %d, %d"%(var1, var2))
print(modifyVar3(var1))
print("Var1 and Var2 in main program = %d, %d"%(var1, var2))
modifyVar4()
print("Var1 and Var2 in main program = %d, %d"%(var1, var2))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Local variables are var1 = 10, var2 = 20
Local variable var1 = 30, and global var2 = 10
Var1 and Var2 in main program = 5, 5
125
Var1 and Var2 in main program = 5, 3
Var1 and Var2 in main program = 25, 3
</code></pre>
<ul>
<li>บรรทัดที่ 2 โปรแกรมประกาศฟังก์ชันชื่อ modifyVar1 มีหน้าที่กำหนดค่า<br>
ให้กับตัวแปรโลคอล var1 = 10 และ var2 = 20 (บรรทัดที่ 3) และพิมพ์ผลลัพธ์ของตัวแปร var1 และ  var2 ออกจอภาพ (บรรทัดที่ 4) ฟังก์ชันนี้ไม่มีพารามิเตอร์เพื่อใช้งาน</li>
<li>บรรทัดที่ 5 โปรแกรมประกาศฟังก์ชันชื่อ modifyVar2 มีหน้าที่ก าหนดค่าให้กับตัวแปรโลคอล var1 = 20 (บรรทัดที่ 6) และพิมพ์<br>
ผลลัพธ์ของตัวแปร var1 และ var2 (โดยใช้ตัวแปร var2 จากภายนอกฟังก์ชัน) ออกจอภาพ (บรรทัดที่ 7) ฟังก์ชันนี้มีพารามิเตอร์ 2 ตัวคือ var1 และ var2</li>
<li>บรรทัดที่ 8 โปรแกรมประกาศฟังก์ชันชื่อ modifyVar3 มีหน้าที่ก าหนดค่าให้กับตัวแปรโกลบอล  (โดยใช้ keyword ว่า global น าหน้าตัวแปร ในบรรทัดที่ 9) var2 = 3 (บรรทัดที่ 10) และส่งค่ากลับเป็น var1**var2 กลับไปยังผู้เรียก (บรรทัดที่ 11 )</li>
<li>บรรทัดที่ 12 โปรแกรมประกาศฟังก์ชันชื่อ modifyVar4 มีหน้าที่กำหนดค่าให้กับตัวแปรโกลบอล var2 = var1**2 (บรรทัดที่ 14) โดยไม่ส่งค่ากลับไปยังผู้เรียก</li>
<li>บรรทัดที่ 16 โปรแกรมประกาศตัวแปรชื่อ var1 มีค่าเท่ากับ 5 และ var2 มีค่าเท่ากับ 5  เช่นเดียวกัน จากนั้นบรรทัดที่ 17 โปรแกรมเรียกฟังก์ชัน modifyVar1 ผลลัพธ์ที่ได้คือ var1 = 10 และ  var2 เท่ากับ 20 เพราะฟังก์ชันเรียกใช้ตัวแปรแบบ var1 และ var2 จากภายในฟังก์ชัน (Local)</li>
<li>บรรทัดที่ 18 โปรแกรมเรียกฟังก์ชัน modifyVar2 พร้อมกับส่งค่าคงที่เป็นอาร์กิวเมนต์ให้กับ  ฟังก์ชัน 2 ค่าคือ 5 และ 10 ผลลัพธ์ที่ได้คือ var1 = 30 และ var2 เท่ากับ 10 เพราะภายในฟังก์ชันได้ กำหนดค่าให้กับตัวแปร var1 = 30 และ var2 เป็นค่าที่รับมาจากภายนอก สรุปว่าฟังก์ชันดังกล่าว  เรียกใช้ตัวแปรแบบโลคอลทั้ง var1 และ var2 โดยที่ตัวแปร var1 และ var2 ภายนอกฟังก์ชันไม่มีการเปลี่ยนแปลงค่าใดๆ (บรรทัดที่ 19)</li>
<li>บรรทัดที่ 20 โปรแกรมเรียกฟังก์ชัน modifyVar3 พร้อมกับส่งค่าคงที่เป็นอาร์กิวเมนต์ให้กับ  ฟังก์ชัน 1 ค่าคือ ค่าในตัวแปร var1 ที่อยู่ภายนอกฟังก์ชัน ผลลัพธ์ที่ได้คือ 125 (ค่า 125 เกิดจาก  var1**var2 = 53) สรุปว่าฟังก์ชันดังกล่าวเรียกใช้ตัวแปรแบบโกลบอลทั้ง var1 และ var2</li>
<li>บรรทัดที่ 21  ทดสอบสั่งพิมพ์ค่าในตัวแปร var1 และ var2 อีกครั้ง ผลปรากฎว่าค่าในตัวแปร var2 เปลี่ยนจาก 5 เป็น  3 เพราะฟังก์ชัน modofyVar3 ทำการกำหนดค่าใหม่ให้กับตัวแปรโกลบอลคือ var2 (var2 = 3)</li>
<li>บรรทัดที่ 22 โปรแกรมเรียกฟังก์ชัน modifyVar4 โดยไม่มีการส่งอาร์กิวเมนต์ใดๆ ให้กับฟังก์ชันซึ่งฟังก์ชันดังกล่าวไม่มีการส่งค่ากลับเพียงแต่ก าหนดค่าตัวแปร var1 = va1**2 เท่านั้น จากนั้น</li>
<li>บรรทัดที่ 23 โปรแกรมทดสอบพิมพ์ค่า var1 และ var2 อีกครั้ง ผลลัพธ์ที่ได้คือ var1 เท่ากับ 25 และ var2 เท่ากับ 3 สรุปว่าฟังก์ชันนี้เรียกใช้ตัวแปรแบบโกลบอลทั้ง var1 และ var2</li>
</ul>
<blockquote>
<p><strong>Note</strong>: เมื่อโปรแกรมภายในฟังก์ชันเรียกใช้ตัวแปรจากภายนอกฟังก์ชัน ต้องใช้คำสั่ง global  นำหน้าตัวแปรที่ใช้งานอยู่ภายในฟังก์ชัน เช่น <strong>global</strong> var1</p>
</blockquote>
<h2 id="การเรียกตัวเอง-หรือการเวียนเกิด-recursion">การเรียกตัวเอง หรือการเวียนเกิด (Recursion)</h2>
<p>การเรียกตัวเอง คือ วิธีการแก้ปัญหาแบบหนึ่ง ที่ใช้วิธีเรียกตัวเองซ้ำ และทำตามหลักการเดิมไปเรื่อย ๆ จนกว่าจะได้คำตอบที่ต้องการ สำหรับปัญหาที่เหมาะที่จะใช้การเรียกตัวเองคือ ปัญหาที่สามารถแบ่งย่อยออกเป็นส่วนๆ ได้ เมื่อผ่านกรรมวิธีแก้ปัญหาแบบเรียกตัวเองแล้ว ปัญหาจะถูกแบ่งออกเป็นส่วนย่อยๆ จำนวนมาก ซ้อนกันเป็นชั้นๆ แต่ละชั้นใช้วิธีการแก้ปัญหาแบบเดียวกัน จนกระทั่งกลายเป็น<br>
ปัญหาย่อยที่เล็กที่สุดที่สามารถหาคำตอบได้ (ซึ่งส่วนใหญ่เป็นค่าคงที่) ค่าคงที่ดังกล่าวจะเป็นค่าที่ทำให้  สามารถหาคำตอบแบบย้อนกลับได้ โดยการรวมผลลัพธ์ที่แก้ปัญหาแล้วจากปัญหาย่อยๆ กลับมาเป็นคำตอบของปัญหาทั้งหมด การประกาศฟังก์ชันการเรียกตัวเองมีรูปแบบดังต่อไปนี้</p>
<pre><code>defname([arg1, arg2,..,argn], n):
	statement(s)
	if condition(n):
		return constant
	else:
		return name([arg1, arg2,..,argn], n-1)
</code></pre>
<p>name คือ ชื่อของฟังก์ชันชนิดเรียกตัวเอง arg1, arg2, …,argn คือพารามิเตอร์ที่ส่งให้กับฟังก์ชันเพื่อใช้ในการประมวลผล (ซึ่งจะมีหรือไม่มีก็ได้ เพราะอยู่ในเครื่องหมาย […]), n คือ พารามิเตอร์ที่ใช้เป็นเงื่อนไขในการหาค่าที่เล็กที่สุด, n-1 คือ การเรียกซ้ำตัวเองโดยการแบ่งย่อยปัญหาไปเรื่อยๆ  จนกว่าเงื่อนไขใน if condition(n) จะเป็นจริง</p>
<p><strong>ตัวอย่างการหาค่ายกกำลัง exponent (exp)</strong> ซึ่งเป็นปัญหาที่สามารถแบ่งย่อยเป็นส่วนๆ ได้จากสมการของ</p>
<pre><code>exp(an) = a1 * a2 * … * an  
สมมุติว่า a = 2 และ n = 4 ดังนั้น exp(24) = 2 * 2 * 2 * 2 = 16
</code></pre>
<pre><code># Computing exponent
def exp(x, n):
    if n == 0:
        return 1 #constant(minimum solution)
    else:
        return x * exp(x, n-1)
print("Exponet of 2^4 = ", exp(2, 4))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Exponet of 2^4 =  16
</code></pre>
<p><strong>ตัวอย่างโปรแกรมของ Factorial และ Fibonacci</strong></p>
<pre><code># Factorial &amp; Fibonacci
#Factorial function
def factorial(n):
    if n == 1:
        return 1  #constant(minimum solution)
    else:
        res = n * factorial(n-1)
        return res

#Fibonacci function
def fib(n):
    if n == 0:
        return 0  #constant(minimum solution)
    elif n == 1:
        return 1  #constant(minimum solution)
    else:
        return fib(n-1) + fib(n-2)
#call both functions
print("Factorial (5) = ",factorial(5))
print("Fibonacci (5) = ",fib(5))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Factorial (5) =  120
Fibonacci (5) =  5
</code></pre>
<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>

    </div>
  </div>
</body>

</html>
